#pragma kernel CSMain

#include "Util.compute"
#include "Table.compute"

static const int NUM_THREADS = 8;

struct Triangle
{
	float3 a_, b_, c_;
};

AppendStructuredBuffer<Triangle> triangles_;
StructuredBuffer<float> points_;
int3 size_;
float threshold_;
float step_;

float4 GetPoint(int x, int y, int z)
{
	return float4(x, y, z, points_[Flatten(size_, int3(x, y, z))]);
}

float3 Interpolate(float4 a, float4 b)
{
	float t = (threshold_ - a.w) / (b.w - a.w);
	return a.xyz + t * (b.xyz - a.xyz);
}

[numthreads(NUM_THREADS, NUM_THREADS, NUM_THREADS)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	if(id.x >= size_.x - 1u || id.y >= size_.y - 1u || id.z >= size_.z - 1u) return;

	float4 cube[8u] = {
		GetPoint(id.x, id.y, id.z),
		GetPoint(id.x + 1, id.y, id.z),
		GetPoint(id.x + 1, id.y, id.z + 1),
		GetPoint(id.x, id.y, id.z + 1),
		GetPoint(id.x, id.y + 1, id.z),
		GetPoint(id.x + 1, id.y + 1, id.z),
		GetPoint(id.x + 1, id.y + 1, id.z + 1),
		GetPoint(id.x, id.y + 1, id.z + 1)
	};

	int configuration = 0;
	for(uint j = 0u; j < 8u; ++j)
	{
		if(cube[j].w >= threshold_)
			configuration |= 1 << j;
	}

	for(uint i = 0u; triangulation[configuration][i] != -1; i += 3u)
	{
		int a0 = cornerIndexAFromEdge[triangulation[configuration][i]];
		int b0 = cornerIndexBFromEdge[triangulation[configuration][i]];

		int a1 = cornerIndexAFromEdge[triangulation[configuration][i + 1u]];
		int b1 = cornerIndexBFromEdge[triangulation[configuration][i + 1u]];

		int a2 = cornerIndexAFromEdge[triangulation[configuration][i + 2u]];
		int b2 = cornerIndexBFromEdge[triangulation[configuration][i + 2u]];

		Triangle t;
		t.a_ = Interpolate(cube[a0], cube[b0]);
		t.b_ = Interpolate(cube[a1], cube[b1]);
		t.c_ = Interpolate(cube[a2], cube[b2]);
		triangles_.Append(t);
	}
}
