#pragma kernel CSMain

#include "Util.compute"
#include "Simplex.compute"

static const int NUM_THREADS = 8;

RWStructuredBuffer<float> points_;
int3 size_;
float3 scale_;
float3 offset_;
uint octaves_;
float persistance_;
float lacunarity_;
float2 lerp_;
float floor_;
float roof_;
float3 sampleOffset_;
float noiseWeight_;
float floorWeight_;
float weightMultiplier_;
float2 blend_;

float Plane(uint3 id)
{
	float amplitude = 1;
	float frequency = 1;
	float weight = 1;

	float density = 0;

	for (uint i = 0u; i < octaves_; ++i)
	{
		float n = snoise((offset_ + id + sampleOffset_) / scale_ * frequency);
		float v = 1 - abs(n);

		v = v * v;
		v *= weight;
		weight = min(max(v * weightMultiplier_, 1), 0);
		density += v * amplitude;

		amplitude *= persistance_;
		frequency *= lacunarity_;
	}

	float final = -((offset_ + id).y - roof_) + density * noiseWeight_;
	if (final < roof_)
	{
		final += floorWeight_;
	}

	return final;
}

float Cavern(uint3 id)
{
	float amplitude = 1;
	float frequency = 1;

	float height = 0;

	for (uint i = 0u; i < octaves_; ++i)
	{
		float3 s = (offset_ + id + sampleOffset_) / scale_ * frequency;
		float value = snoise(s);

		height += value * amplitude;

		amplitude *= persistance_;
		frequency *= lacunarity_;
	}

	return InverseLerp(lerp_.x, lerp_.y, height);
}

[numthreads(NUM_THREADS, NUM_THREADS, NUM_THREADS)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float value = 1.0;

	if(offset_.y + id.y >= floor_)
	{
		value = Cavern(id);
	}

	if(offset_.y + id.y >= roof_ - blend_.x)
	{
		float d = roof_ + blend_.y + blend_.x - (offset_.y + id.y);
		float delta = d < 0 ? 1.0 : (d - blend_.x - blend_.y) / (blend_.y + blend_.x);
		value = Plane(id) * delta + value * (1.0 - delta);
	}

	points_[Flatten(size_, id)] = value;
}
